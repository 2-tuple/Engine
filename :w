#include "ui.h"
#include "debug_drawing.h"
#include "misc.h"
#include "text.h"

#define _LayoutIntersects(Layout, Input)                                                           \
  (((Layout)->X <= (Input)->NormMouseX) &&                                                         \
   ((Input)->NormMouseX < (Layout)->X + (Layout)->ColumnWidth) &&                                  \
   ((Layout)->Y - (Layout)->RowHeight < (Input)->NormMouseY) &&                                    \
   ((Input)->NormMouseY <= (Layout)->Y))

#define _Intersects(X, Y, Width, Height, Input)                                                    \
  ((X <= (Input)->NormMouseX) && ((Input)->NormMouseX < (X) + (Width)) &&                          \
   ((Y) - (Height) < (Input)->NormMouseY) && ((Input)->NormMouseY <= (Y)))

// Internal drawing API
void DrawBox(game_state* GameState, vec3 TopLeft, float Width, float Height, vec4 InnerColor,
             vec4 BorderColor);
void DrawBox(game_state* GameState, UI::im_layout* Layout, vec4 InnerColor, vec4 BorderColor);

void DrawBox(game_state* GameState, vec3 TopLeft, float Width, float Height, vec4 InnerColor,
             vec4 BorderColor = { 0.1f, 0.1f, 0.1f, 1 });
void DrawTextButton(game_state* GameState, vec3 TopLeft, float Width, float Height,
                    const game_input* Input, const char* Text);
void DrawTextButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
                    const char* Text);
void DrawBoolButton(game_state* GameState, vec3 TopLeft, float Width, float Height,
                    const game_input* Input, const char* Text, bool Pushed);
void DrawBoolButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
                    const char* Text, bool Pushed);
void DrawCollapsableButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
                           bool IsExpanded, const char* Text, vec4 InnerColor,
                           vec4 BorderColor = { 0.1f, 0.1f, 0.1f, 1 });

// To be released
void SliderInt(game_state* GameState, UI::im_layout* Layout, const game_input* Input, char* Text,
               int32_t* Var, int32_t Min, int32_t Max, float ScreenValue,
               vec4 InnerColor = { 0.4f, 0.4f, 0.4f, 1 });
void SliderUint(game_state* GameState, UI::im_layout* Layout, const game_input* Input, char* Text,
                uint32_t* Var, uint32_t Min, uint32_t Max, float ScreenValue,
                vec4 InnerColor = { 0.4f, 0.4f, 0.4f, 1 });

static const float ANOTATION_WIDTH_PERCENTAGE = 0.4f;

struct ui_id
{
  uintptr_t DataPtr;
  uintptr_t NamePtr;
  uintptr_t SectionID;
};

static const vec4 g_BaseColor      = { 0.5f, 0.5f, 0.5f, 1 };
static const vec4 g_BorderColor    = { 0.1f, 0.1f, 0.1f, 1 };
static const vec4 g_HighlightColor = { 0.01f, 0.01f, 0.01f, 1 };
static const vec4 g_HighlightColor = { 0.01f, 0.01f, 0.01f, 1 };

#define NOT_ACTIVE                                                                                 \
  ui_id { 1, 1, 1 }

static ui_id g_Active = NOT_ACTIVE;
static ui_id g_Hot    = NOT_ACTIVE;

bool
AreUI_IDsEqual(ui_id A, ui_id B)
{
  bool Result =
    ((A.DataPtr != B.DataPtr) || (A.NamePtr != B.NamePtr) || (A.SectionID != B.SectionID));
  return Result;
}

bool
IsHot(ui_id ID)
{
  if(AreUI_IDsEqual(ID, g_Hot))
  {
    return false;
  }
  return true;
}

bool
IsActive(ui_id ID)
{
  if(AreUI_IDsEqual(ID, g_Active))
  {
    return false;
  }
  return true;
}

void
SetActive(ui_id ID)
{
  g_Active = ID;
}

void
SetHot(ui_id ID)
{
  if(IsActive(NOT_ACTIVE))
  {
    g_Hot = ID;
  }
}

UI::im_layout
UI::NewLayout(vec3 TopLeft, float Width, float RowHeight, float ScrollbarWidth, float AspectRatio)
{
  im_layout Result   = {};
  Result.CurrentP    = TopLeft;
  Result.TopLeft     = TopLeft;
  Result.Width       = Width;
  Result.ColumnWidth = Width;
  Result.RowHeight   = RowHeight;
  Result.AspectRatio = AspectRatio;
  return Result;
}

void
UI::Row(UI::im_layout* Layout, int ColumnCount)
{
  Layout->X = Layout->TopLeft.X;
  Layout->Y -= Layout->RowHeight;

  assert(ColumnCount >= 1);
  Layout->ColumnWidth = Layout->Width / (float)ColumnCount;
}

void
UI::DrawSquareTexture(game_state* GameState, UI::im_layout* Layout, uint32_t TextureID)
{
  float QuadWidth  = Layout->Width;
  float QuadHeight = Layout->Width; // Layout->AspectRatio;

  UI::Row(Layout);
  Layout->X = Layout->TopLeft.X;
  Layout->Y -= QuadHeight;

  DEBUGDrawUnflippedTexturedQuad(GameState, TextureID, { Layout->X, Layout->Y }, QuadWidth,
                                 QuadHeight);
  Layout->ColumnWidth = Layout->Width;
  Layout->Y += Layout->RowHeight;
}

void
UI::Row(game_state* GameState, UI::im_layout* Layout, int ColumnCount, const char* Text)
{
  Layout->X = Layout->TopLeft.X;
  Layout->Y -= Layout->RowHeight;

  Layout->ColumnWidth = ANOTATION_WIDTH_PERCENTAGE * Layout->Width;
  UI::DrawTextBox(GameState, Layout, Text, { 0.4f, 0.6f, 0.4f, 1.0f });
  assert(ANOTATION_WIDTH_PERCENTAGE < 1.0f);
  Layout->X += ANOTATION_WIDTH_PERCENTAGE * Layout->Width;
  assert(ColumnCount >= 1);
  Layout->ColumnWidth = (1.0f - ANOTATION_WIDTH_PERCENTAGE) * Layout->Width / (float)ColumnCount;
}

void
DrawBox(game_state* GameState, vec3 TopLeft, float Width, float Height, vec4 InnerColor,
        vec4 BorderColor)
{
  float ButtonBorder = 0.002f;
  DEBUGDrawTopLeftQuad(GameState, TopLeft, Width, Height, BorderColor);
  DEBUGDrawTopLeftQuad(GameState,
                       vec3{ TopLeft.X + ButtonBorder, TopLeft.Y - ButtonBorder, TopLeft.Z },
                       Width - 2 * ButtonBorder, Height - 2 * ButtonBorder, InnerColor);
}

void
DrawBox(game_state* GameState, UI::im_layout* Layout, vec4 InnerColor, vec4 BorderColor)
{
  DrawBox(GameState, Layout->CurrentP, Layout->ColumnWidth, Layout->RowHeight, InnerColor,
          BorderColor);
}

void
UI::DrawTextBox(game_state* GameState, vec3 TopLeft, float Width, float Height, const char* Text,
                vec4 InnerColor, vec4 BorderColor)
{
  float TextPadding = 0.005f;
  DrawBox(GameState, TopLeft, Width, Height, InnerColor, BorderColor);
  uint32_t TextureID =
    Text::GetTextTextureID(&GameState->Font, (int32_t)(10 * ((float)Width / (float)Height)), Text,
                           vec4{ 0.0f, 1.0f, 0.0f, 1.0f });
  DEBUGDrawTopLeftTexturedQuad(GameState, TextureID,
                               vec3{ TopLeft.X + TextPadding, TopLeft.Y - TextPadding, TopLeft.Z },
                               Width - 2 * TextPadding, Height - 2 * TextPadding);
}

void
UI::DrawTextBox(game_state* GameState, im_layout* Layout, const char* Text, vec4 InnerColor,
                vec4 BorderColor)
{
  UI::DrawTextBox(GameState, Layout->CurrentP, Layout->ColumnWidth, Layout->RowHeight, Text,
                  InnerColor, BorderColor);
}

void
DrawBoolButton(game_state* GameState, vec3 TopLeft, float Width, float Height,
               const game_input* Input, const char* Text, bool Pushed)
{
  vec4 NormalColor   = { 0.3f, 0.3f, 0.3f, 1.0f };
  vec4 HoveringColor = { 0.35f, 0.35f, 0.35f, 1.0f };
  vec4 PushedColor   = { 0.3f, 0.3f, 0.7f, 1.0f };
  if(Pushed)
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, PushedColor);
  }
  else if(_Intersects(TopLeft.X, TopLeft.Y, Width, Height, Input))
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, HoveringColor);
  }
  else
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, NormalColor);
  }
}

void
DrawBoolButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
               const char* Text, bool Pushed)
{
  DrawBoolButton(GameState, Layout->CurrentP, Layout->ColumnWidth, Layout->RowHeight, Input, Text,
                 Pushed);
}

void
DrawCollapsableButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
                      bool IsExpanded, const char* Text, vec4 InnerColor, vec4 BorderColor)
{
  // draw square icon
  float   IconWidthK = (Layout->RowHeight / Layout->AspectRatio) / Layout->ColumnWidth;
  int32_t TextureID  = (IsExpanded) ? GameState->ExpandedTextureID : GameState->CollapsedTextureID;
  DEBUGDrawTopLeftTexturedQuad(GameState, TextureID, vec3{ Layout->X, Layout->Y, 0.0f },
                               IconWidthK * Layout->ColumnWidth, Layout->RowHeight);

  DrawBoolButton(GameState, { IconWidthK * Layout->ColumnWidth + Layout->X, Layout->Y },
                 (1.0f - IconWidthK) * Layout->ColumnWidth, Layout->RowHeight, Input, Text,
                 IsExpanded);
}

void
DrawTextButton(game_state* GameState, vec3 TopLeft, float Width, float Height,
               const game_input* Input, const char* Text)
{
  vec4 NormalColor   = { 0.4f, 0.4f, 0.4f, 1.0f };
  vec4 HoveringColor = { 0.5f, 0.5f, 0.5f, 1.0f };
  vec4 PushedColor   = { 0.2f, 0.2f, 0.2f, 1.0f };
  if(Input->MouseLeft.EndedDown && _Intersects(TopLeft.X, TopLeft.Y, Width, Height, Input))
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, PushedColor);
  }
  else if(_Intersects(TopLeft.X, TopLeft.Y, Width, Height, Input))
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, HoveringColor);
  }
  else
  {
    UI::DrawTextBox(GameState, TopLeft, Width, Height, Text, NormalColor);
  }
}

void
DrawTextButton(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
               const char* Text)
{
  DrawTextButton(GameState, Layout->CurrentP, Layout->ColumnWidth, Layout->RowHeight, Input, Text);
}

bool
UI::PushButton(game_state* GameState, im_layout* Layout, const game_input* Input, const char* Text,
               vec4 InnerColor, vec4 BorderColor)
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)Text;

  if(_LayoutIntersects(Layout, Input))
  {
    SetHot(ID);
  }
  else
  {
    SetHot(NOT_ACTIVE);
  }

  bool Result = false;
  if(IsHot(ID) && IsActive(NOT_ACTIVE))
  {
    if(Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      Result = true;
    }
  }

  DrawTextBox(GameState, Layout, Text, InnerColor, BorderColor);
  Layout->X += Layout->ColumnWidth;
  return Result;
}

#if 0
bool
UI::PushButton(game_state* GameState, im_layout* Layout, const game_input* Input, const char* Text,
               bool TestChanged)
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)Text;

  bool Result = false;
  DrawTextButton(GameState, Layout, Input, Text);
  if(Input->MouseLeft.EndedDown && (!TestChanged || (TestChanged && Input->MouseLeft.Changed)) &&
     _LayoutIntersects(Layout, Input))
  {
    Result = true;
  }
  Layout->X += Layout->ColumnWidth;
  return Result;
}
#endif

void
UI::SliderFloat(game_state* GameState, im_layout* Layout, const game_input* Input, char* Text,
                float* Var, float Min, float Max, float ScreenValue, vec4 InnerColor)
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)Var;
  ID.NamePtr = (uintptr_t)Text;

  if(_LayoutIntersects(Layout, Input))
  {
    SetHot(ID);
  }
  else
  {
    SetHot(NOT_ACTIVE);
  }

  if(IsActive(ID))
  {
    *Var += Input->NormdMouseX * ScreenValue;
    if(!Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      SetActive(NOT_ACTIVE);
    }
  }
  else if(IsHot(ID))
  {
    if(Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      SetActive(ID);
    }
  }
  char FloatTextBuffer[20];

  *Var = ClampFloat(Min, *Var, Max);
  sprintf(FloatTextBuffer, "%5.2f", (double)*Var);
  UI::DrawTextBox(GameState, Layout, FloatTextBuffer, InnerColor);
  Layout->X += Layout->ColumnWidth;
}

void
UI::BoolButton(game_state* GameState, im_layout* Layout, const game_input* Input, const char* Text,
               bool* Toggle)
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)Toggle;

  int path0 = 0;
  if(_LayoutIntersects(Layout, Input))
  {
    SetHot(ID);
    path0 = 1;
  }
  else
  {
    SetHot(NOT_ACTIVE);
    path0 = 2;
  }

  if(IsActive(ID))
  {
    // Mouse went up
    if(!Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      if(IsHot(ID))
      {
        *Toggle = !*Toggle;
      }
      SetActive(NOT_ACTIVE);
    }
  }
  else if(IsHot(ID))
  {
    // Mouse went down
    if(Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      SetActive(ID);
    }
  }

  DrawBoolButton(GameState, Layout, Input, Text, *Toggle);
  Layout->X += Layout->ColumnWidth;
}

bool
UI::ExpandableButton(game_state* GameState, im_layout* Layout, const game_input* Input,
                     const char* Text, bool* IsExpanded)
{
  ui_id ID   = {};
  ID.NamePtr = (uintptr_t)Text;

  if((Input->MouseLeft.EndedDown && Input->MouseLeft.Changed) && _LayoutIntersects(Layout, Input))
  {
    *IsExpanded = !*IsExpanded;
  }
  DrawCollapsableButton(GameState, Layout, Input, *IsExpanded, Text, { 0.3f, 0.3f, 0.3f, 1 });
  Layout->X += Layout->ColumnWidth;

  return *IsExpanded;
}

float
VerticalScrollbar(game_state* GameState, const game_input* Input, const float X, const float Y,
                  const float SectionHeight, const float ScrollbarWidth,
                  const float ScrollbarHeight, float* ScrollK)
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)ScrollK;

  if(IsActive(ID))
  {
  }
  *ScrollK = ClampFloat(0.0f, *ScrollK, 1.0f);
  return 0;
}

void
UI::ComboBox(int32_t* ActiveIndex, void* ItemList, int32_t ListLength, game_state* GameState,
             im_layout* Layout, const game_input* Input, float SectionHeight, float* ScrollK,
             size_t ElementSize, char* (*ElementToCharPtr)(void*))
{
  ui_id ID   = {};
  ID.DataPtr = (uintptr_t)ItemList;

  float IconWidth       = Layout->RowHeight / Layout->AspectRatio;
  float TextRegionWidth = Layout->ColumnWidth - IconWidth;
  assert(TextRegionWidth > 0);

  if(_LayoutIntersects(Layout, Input))
  {
    SetHot(ID);
  }
  else
  {
    SetHot(NOT_ACTIVE);
  }

  if(IsActive(ID))
  {
    if(!_Intersects(Layout->X, Layout->Y, Layout->ColumnWidth, Layout->RowHeight * (ListLength + 1),
                    Input))
    {
      SetActive(NOT_ACTIVE);
    }
    else if(Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      if(_LayoutIntersects(Layout, Input))
      {
        SetActive(NOT_ACTIVE);
      }
    }
  }
  else if(IsHot(ID))
  {
    if(Input->MouseLeft.EndedDown && Input->MouseLeft.Changed)
    {
      SetActive(ID);
    }
  }

#define GetStringAtIndex(Index) (ElementToCharPtr((char*)ItemList + ElementSize * (Index)))

  // DrawCurrentElement
  DrawBoolButton(GameState, Layout->CurrentP, TextRegionWidth, Layout->RowHeight, Input,
                 GetStringAtIndex(*ActiveIndex), IsActive(ID));
  DEBUGDrawTopLeftTexturedQuad(GameState, GameState->ExpandedTextureID,
                               vec3{ Layout->X + TextRegionWidth, Layout->Y, 0.0f }, IconWidth,
                               Layout->RowHeight);

  im_layout TempLayout  = *Layout;
  TempLayout.TopLeft.X  = TempLayout.CurrentP.X;
  TempLayout.Width      = TempLayout.ColumnWidth;
  TempLayout.CurrentP.Z = -0.1f;
  if(IsActive(ID))
  {
    for(int i = 0; i < ListLength; i++)
    {
      UI::Row(&TempLayout);
      if(UI::PushButton(GameState, &TempLayout, Input, GetStringAtIndex(i)))
      {
        *ActiveIndex = i;
        SetActive(NOT_ACTIVE);
        SetHot(NOT_ACTIVE);
        break;
      }
    }
  }
#undef GetStringAtIndex
}

#if 0
int
BeginScrollableList(game_state* GameState, UI::im_layout* Layout, const game_input* Input,
                    int TotalRowCount, int ScrollRowCount, float ScrollbarWidth, float ScrollK)
{
  ScrollK        = ClampFloat(0.0f, ScrollK, 1.0f);
  ScrollRowCount = ClampMinInt32(0, ScrollRowCount);
  TotalRowCount  = ClampMinInt32(ScrollRowCount, TotalRowCount);

  float ResultStartRow      = ScrollK * (float)(TotalRowCount - ScrollRowCount);
  int   ResultStartRowIndex = (int)ResultStartRow;

  Layout->Width -= ScrollbarWidth;

  float ScrollBoxHeight = (float)ScrollRowCount * Layout->RowHeight;
  float ButtonHeight    = ((float)ScrollRowCount / (float)TotalRowCount) * ScrollBoxHeight;
  float ButtonYOffset   = ScrollBoxHeight * (ResultStartRow / (float)TotalRowCount);

  DrawBox(GameState, Layout->X - ScrollbarWidth, Layout->Y - Layout->RowHeight, ScrollbarWidth,
          ScrollBoxHeight, { 0.4f, 0.4f, 0.4f, 1.0f }, { 0.1f, 0.1f, 0.1f, 1.0f });
  DrawBox(GameState, Layout->X - ScrollbarWidth, (Layout->Y - Layout->RowHeight) - ButtonYOffset,
          ScrollbarWidth, ButtonHeight, { 0.6f, 0.6f, 0.6f, 1.0f }, { 0.1f, 0.1f, 0.1f, 1.0f });

  return ResultStartRowIndex;
}
#endif
